### SSH
SSH (англ. Secure Shell — «безопасная оболочка») — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой. Шифрует весь трафик, включая и передаваемые пароли. SSH допускает выбор различных алгоритмов шифрования. SSH-клиенты и SSH-серверы доступны для большинства операционных систем. SSH позволяет безопасно передавать в незащищённой среде практически любой другой сетевой протокол. Таким образом, можно не только удалённо работать на компьютере через командную оболочку, но и передавать по шифрованному каналу звуковой поток или видео (например, с веб-камеры). Используя ряд технологий шифрования, SSH обеспечивает механизм для установления криптографически защищенного соединения между двумя сторонами, аутентификации каждой стороны, обмена командами и выходными данными. Для обеспечения передачи информации SSH использует несколько различных методов управления данными в разных точках транзакции. К ним относится хеширование и шифрование (симметричное и асимметричное).

### Хеширование 
Хеширование (англ. hashing) — преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. Функция, воплощающая алгоритм и выполняющая преобразование, называется «хеш-функцией» или «функцией свёртки». Исходные данные называются входным массивом, «ключом» или «сообщением». Результат преобразования называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».
При изменении исходного текста даже на один знак результат хеш-функции полностью меняется.
В общем случае нет однозначного соответствия между исходными данными и результатом (хешем). Возвращаемые хеш-функцией значения менее разнообразны, чем значения входного массива. Случай, при котором хеш-функция преобразует несколько разных сообщений в одинаковые сводки, называется «коллизией». Вероятность возникновения коллизий используется для оценки качества хеш-функций. Из хэша нельзя получить входные данные. Подобрать значение можно только перебором.

**Криптографическое хеширование** – это совокупность методов создания краткой «подписи» или сводки набора информации. Главными отличительными признаками методов хеширования являются их необратимость, непредсказуемость и уникальность.
Хэшируя одно и то же сообщение с помощью одной и той же функции хэширования, вы получите один и тот же хэш. Изменится любая часть данных – получите совершенно другой хэш. Пользователь не должен иметь возможность воссоздавать исходное сообщение из хэша, но должен иметь возможность определить, выдало ли данное сообщение заданный хэш.
Учитывая эти свойства, хеши в основном используются для подтверждения целостности данных и проверки подлинности связи. Основное использование хэширования в SSH – это HMAC или хэш-коды аутентификации сообщений. Они позволяют подтвердить, что текст принятого сообщения не был изменен или поврежден.

### Шифрование
Шифрование — обратимое преобразование информации в целях сокрытия от неавторизованных лиц, с предоставлением авторизованным лицам доступа к ней. Главным образом, шифрование служит задачей соблюдения конфиденциальности передаваемой информации. Важной особенностью любого алгоритма шифрования является использование ключа, который утверждает выбор конкретного преобразования из совокупности возможных для данного алгоритма. Пользователи являются авторизованными, если они знают ключ. Согласно Шеннону, криптографическая стойкость системы шифрования должна определяться только ключом. Идея шифрования состоит в том, что злоумышленник, перехватив зашифрованные данные и не имея к ним ключа, не может ни прочитать, ни изменить передаваемую информацию. С помощью шифрования обеспечиваются три состояния безопасности информации:

* Конфиденциальность - шифрование используется для скрытия информации от неавторизованных пользователей при передаче или при хранении.
* Целостность - шифрование используется для предотвращения изменения информации при передаче или хранении.
* Идентифицируемость - шифрование используется для аутентификации источника информации и предотвращения отказа отправителя информации от того факта, что данные были отправлены именно им.

В целом, шифрование состоит из двух составляющих — зашифровывание и расшифровывание. Расшифровывание, которое осуществляется без знания пароля (например, с помощью перебора) называется дешифрованием.

Существует два основных способа шифрования данных: симметричное шифрование (общий секретный ключ) и асимметричное шифрование (пара открытый/приватный ключ).

#### Симметричное шифрование
**Симметричное шифрование** (или шифрованием с общим секретным ключом) – это способ шифрования, при котором для шифрования и дешифровки данных между сторонами используется один и тот же ключ. Это означает, что любой, у кого есть ключ, может шифровать и дешифровать сообщения других пользователей, у которых есть этот же ключ. Симметричные ключи используются в SSH для шифрования всего соединения.

При использовании симметричного шифрования один и тот же ключ используется как для шифрования, так и для расшифровывания данных. Если стороны хотят обменяться зашифрованными сообщениями в безопасном режиме, то у обеих сторон должны быть одинаковые симметричные ключи. Такой тип шифрования используется для большого объёма данных (так как симметричное шифрование является более быстрым). 

Ключ для симметричного шифрования зависит от сессии и обеспечивает шифрование данных, передаваемых между сервером и клиентом. Как только соединение установлено, ключ шифрует все данные между сервером и клиентом. Это делается до аутентификации клиента. Симметричное шифрование позволяет защитить парольную аутентификацию от отслеживания. Клиент и сервер устанавливают этот секретный ключ, который не должен быть известен посторонним. Секретный ключ создается посредством так называемого алгоритма обмена ключами. Этот обмен приводит к тому, что сервер и клиент одновременно используют один и тот же ключ независимо друг от друга.

Протокол SSH может использовать различные системы симметричного шифрования, такие как AES, Blowfish, 3DES, CAST128 и Arcfour. Сервер и клиент могут определить список поддерживаемых шифров и упорядочить его в зависимости от своих предпочтений. Первый шифр из списка клиента, который поддерживается сервером, используется в качестве алгоритма шифрования в обоих направлениях.

#### Асимметричное шифрование
**Асимметричное шифрование** (или шифрование с открытым ключом) отличается от симметричного тем, что для передачи данных в одном направлении необходимы два связанных ключа. Один из них называется закрытым (или секретным, или приватным) ключом, а второй – открытым ключом. Оба ключа используются в паре: последовательное применение к тексту открытого, а потом закрытого ключа позволяет получить исходный текст. Порядок неважен - можно использовать закрытый ключ, а потом открытый, - результатом всё равно будет исходный текст. Если владелец ключевой пары "зашифрует" (подпишет) данные своим приватным ключом, то каждый сможет убедиться в том, что данные были отправлены именно владельцем приватного ключа и не были изменены третьей стороной. Это является основой электронно-цифровой подписи.

Пусть $`e`$ - ключ шифрования (открытый ключ), $`d`$ - ключ расшифрования (закрытый ключ) некоторого пользователя username, $`E_e`$ - функция шифрования (encrypt), $`D_d`$ функция расшифровывания (decrypt). Сами функции определяются в стандарте шифрования, например, RSA. Пары ключей генерируются для каждого пользователя, и у одного пользователя может быть множество пар ключей.

При этом для заданной строки $`m`$ обозначим $`E_e(m)=c`$, где $`c`$ - это шифрованный текст. С помощью функции расшифрования можно по шифрованному тексту получить исходный $`D_d(c)=m`$. Это работает в обе стороны, то есть последовательное применение двух связанных ключей даёт исходный текст:

$`E_e(D_d(m))=m`$

$`D_d(E_e(m))=m`$

При этом знание только одного ключа недостаточно - исходный текст получить не выйдет:

$`D_d(D_d(m))!=m`$

$`E_e(E_e(m))!=m`$

В наших обозначениях, сами функции $`E`$, $`D`$ и открытый ключ $`e`$ доступны всем. Закрытый ключ $`d`$ доступен только владельцу ключа. 

$`D_d(m)=c`$ позволяет подписать сообщение (ЭЦП). Владелец публикует сообщение $`username, m, c`$ - и любой человек может проверить с помощью открытого ключа пользователя username, что $`m == E_e(D_d(c))`$ - тогда именно владелец закрытого ключа username подписал сообщение m.

$`E_e(m)=c`$ позволяет передать сообщение для username, при этом никто другой сообщение m прочитать не может. Владелец-username и только он может получить исходное сообщение $`D_d(c)=m`$.

Открытый ключ можно свободно распространять. Он связан с закрытым ключом, но закрытый ключ нельзя вычислить из открытого ключа. Математическая взаимосвязь между этими ключами позволяет открытому ключу шифровать сообщения, которые могут быть дешифрованы только закрытым ключом. Это одностороннее шифрование: открытый ключ не может расшифровывать зашифрованные им данные и все, что отправляет его закрытый ключ.

Закрытый ключ нужно хранить в секрете и **никому не передавать**. Это базовое правило асимметричного шифрования. Закрытый ключ является единственным компонентом, способным расшифровывать данные, которые были зашифрованы с помощью связанного с ним открытого ключа.

SSH использует асимметричное шифрование в нескольких разных задачах. Во время начального процесса обмена ключами для настройки симметричного шифрования сессии используется асимметричное шифрование. На данном этапе обе стороны генерируют временные пары ключей и обмениваются открытыми ключами, чтобы создать общий секретный ключ для симметричного шифрования.

Более широко асимметричное шифрование SSH используется для беспарольной аутентификации на основе ключей. Пары ключей SSH могут использоваться для аутентификации клиента на сервере. Клиент создает пару ключей и подгружает открытый ключ на удаленный сервер в файл authorized_keys в каталоге ~/.ssh (это можно сделать командной ssh-copy-id).

### Устройство SSH
В протоколе SSH используется модель *клиент-сервер* для аутентификации двух сторон и шифрования данных между ними. Серверный компонент прослушивает соединения по указанному порту (по умолчанию 22). Он отвечает за ведение переговоров о безопасном подключении, аутентификацию подключаемой стороны и создание правильной среды для клиента в случае, если он предоставил валидные учетные данные. Клиент отвечает за рукопожатие TCP с сервером, согласование безопасного соединения, проверку соответствия сервера ранее записанной информации и за предоставление учетных данных для аутентификации.

Сессия SSH устанавливается в два этапа. Первый этап – согласование и установка шифрования для защиты будущего взаимодействия. Второй этап – аутентификация пользователя и принятие решения о том, должен ли клиент получить доступ к серверу. Когда клиент инициирует TCP-соединение, сервер отвечает версиями протокола, которые он поддерживает. Если клиент тоже поддерживает одну из версий протокола, соединение продолжается. Сервер также предоставляет свой открытый ключ хоста, с помощью которого клиент может подтвердить, что подключается к нужному хосту.

На этом этапе обе стороны обсуждают ключ сеанса с помощью алгоритма Диффи-Хеллмана. Этот алгоритм (и его варианты) позволяет каждой стороне объединить свои личные данные с общедоступными данными другой системы, чтобы получить одинаковый секретный ключ для сессии. Ключ сессии будет использоваться для шифрования всей сессии. Открытый и закрытый ключ, который используется на этом этапе, не совпадают с парой ключей SSH, используемой для аутентификации клиента на сервере.

Базовый алгоритм Диффи-Хеллмана работает так:
* Обе стороны выбирают большое простое число, которое будет служить в качестве начального значения.
* Обе стороны выбирают генератор шифрования (обычно AES), который будет предопределенным образом управлять значениями.
* Независимо каждая сторона придумывает другое простое число, которое хранится в секрете от другой стороны. Это число используется как закрытый ключ для этого взаимодействия (это не тот SSH-ключ, что используется для аутентификации).
* Сгенерированный закрытый ключ, генератор шифрования и общее простое число используются для создания открытого ключа, который является производным от закрытого ключа, но который может также использоваться другой стороной.
* Затем оба участника обмениваются открытыми ключами.
* Каждая сторона использует свой собственный закрытый ключ, открытый ключ другой стороны и общее простое число для вычисления общего секретного ключа. В результате обе стороны должны получить один и тот же секретный ключ.

Общий секретный ключ затем используется для шифрования всех последующих сообщений.

Симметричное шифрование, которое используется для такого соединения, называется бинарным протоколом пакетов. Вышеупомянутый процесс позволяет каждой стороне одинаково участвовать в создании общего ключа, благодаря чему ни одна из сторон не может полностью контролировать этот ключ. Кроме того, когда обе стороны получают одинаковый ключ, нет необходимости отправлять эту информацию по небезопасным каналам.

Сгенерированный ключ – это симметричный ключ, который используется для шифрования и расшифровки сообщений. Цель этого ключа – заключить всю дальнейшую связь в зашифрованный туннель, который не сможет расшифровать злоумышленник. После этого этапа начинается аутентификация клиента.

Следующий этап подразумевает аутентификацию пользователя и определение доступа. Существует несколько различных методов, которые могут использоваться для аутентификации на основе того, какие данные принимает сервер. Простейшим методом является парольная аутентификация, при которой сервер просто запрашивает у клиента пароль учетной записи. Пароль отправляется через шифрованное соединение, поэтому он защищен от посторонних. Несмотря на то, что пароль шифруется при передаче, этот метод обычно не рекомендуется использовать из-за ограничений сложности пароля. Автоматизированные сценарии очень легко подбирают пароли обычной длины.

Самой популярной и рекомендуемой альтернативой парольной аутентификации является аутентификация на основе ключей SSH. Пары SSH-ключей являются асимметричными ключами, что означает, что два связанных ключа служат для разных функций. Открытый ключ используется для шифрования данных, которые могут быть расшифрованы только с помощью закрытого ключа. Открытый ключ можно свободно передавать, потому что вычислить закрытый ключ из открытого ключа невозможно.

Аутентификация на основе ключей SSH начинается после того, как установлено симметричное шифрование. Процедура выполняется следующим образом:
* Клиент отправляет ID для пары ключей, с помощью которой он хотел бы аутентифицироваться на сервере.
* Сервер проверяет файл authorized_keys учетной записи, с помощью которой клиент пытается выполнить вход клиент.
* Если в файле обнаружен открытый ключ и его ID совпадает с тем, что отправил клиент, сервер генерирует случайное число и использует открытый ключ для шифрования этого числа.
* Сервер отправляет клиенту это зашифрованное сообщение.
* Если клиент на самом деле клиент имеет связанный закрытый ключ, он сможет расшифровать сообщение с помощью этого ключа и указать переданное число.
* Клиент объединяет дешифрованное число с общим ключом сессии, который используется для шифрования связи, и вычисляет хеш MD5 этого значения.
* Затем клиент отправляет этот хеш MD5 обратно на сервер в качестве ответа на сообщение с зашифрованным числом.
* Сервер использует общий ключ сеанса и исходное число, которое он отправил клиенту, для вычисления значения MD5. Он сравнивает свой результат с тем, что отправил ему клиент. Если эти два значения совпадают, это доказывает, что клиент имеет закрытый ключ. Клиент проходит аутентификацию.

Как видите, асимметрия ключей позволяет серверу шифровать сообщения клиенту с помощью открытого ключа. Затем клиент может доказать, что он имеет закрытый ключ, для чего ему нужно дешифровать полученное сообщение.
